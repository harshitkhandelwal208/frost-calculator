<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Clan Capital Frost Planner — Fixed</title>
<!-- ======= Styles ======= -->
<style>
  :root{
    --sidebar-w: 260px;
    --cell-size: 24px;
    --grid-size: 30;
  }
  #grid { touch-action: none; transform-origin: 0 0; }
  body {
    margin: 0;
    height: 100vh;
    display: flex;
    font-family: Inter, system-ui, Arial;
    background: #f0f2f5;
  }

  /* Sidebar */
  #sidebar {
    width: var(--sidebar-w);
    padding: 12px;
    box-sizing: border-box;
    background: #151a22;
    color: #fff;
    display:flex;
    flex-direction: column;
    gap:10px;
  }
  #sidebar h2 { margin:4px 0 8px 0; font-size:18px; }
  #controls { display:flex; gap:8px; align-items:center; }
  .switch{position:relative;width:44px;height:24px}
  .switch input{display:none}
  .slider{position:absolute;inset:0;background:#666;border-radius:24px}
  .slider:before{content:"";position:absolute;left:4px;top:4px;width:16px;height:16px;background:#fff;border-radius:50%;transition:transform .18s}
  .switch input:checked + .slider{background:#2ea44f}
  .switch input:checked + .slider:before{transform:translateX(20px)}
  #modeLabel{font-size:13px;margin-left:6px}
  .frost-center {
    position:absolute;
    width:8px;
    height:8px;
    border-radius:50%;
    background:#ff2b2b;
    transform:translate(-50%,-50%);
    pointer-events:none;
    z-index:5;
  }

  #defenseScroller {
    background:#0e1115;
    padding:8px;
    border-radius:8px;
    display:flex;flex-wrap:wrap;gap:8px;max-height:48vh;overflow:auto;
  }
  #defenseScroller img {
    width:46px;height:46px;object-fit:contain;border-radius:6px;background:#222;cursor:grab;
    border:2px solid transparent;
  }
  #defenseScroller img:active{cursor:grabbing}

  button, .small {
    background:#0c7bdc;border:none;color:white;padding:8px;border-radius:6px;cursor:pointer;font-size:13px;
  }
  button.secondary { background:#6c757d;}
  #exportBtn{width:100%}
  .hint{font-size:12px;color:#98a0ab;margin-top:6px}

  /* Main Area */
  #main {
    flex:1;
    display:flex;
    gap:12px;
    padding:12px;
    box-sizing:border-box;
    align-items:flex-start;
  }
  #gridArea {
    touch-action: none; /* disable browser gestures */
    overflow: hidden;
    position: relative;
  }

  #grid {
    transform-origin: 0 0;
    transition: transform 0.05s linear;
  }

  /* Grid container */
  #gridArea{
    background:linear-gradient(#dfe6ee,#e7ecf3);
    padding:10px;border-radius:8px;
  }
  #gridWrapper{
    overflow: hidden;
    touch-action: none;
  }

  #grid {
    width: calc(var(--cell-size) * var(--grid-size) + 30px);
    height: calc(var(--cell-size) * var(--grid-size) + 30px);
    display: grid;
    grid-template-columns: repeat(var(--grid-size), var(--cell-size));
    grid-template-rows: repeat(var(--grid-size), var(--cell-size));
    gap:1px;
    background: #222;
    border-radius:6px;
    position: relative;
    user-select: none;
  }

  .cell {
    width: var(--cell-size);
    height: var(--cell-size);
    background: #6b7280;
    display:flex;align-items:center;justify-content:center;
    font-size:9px;color:#fff;
    box-sizing:border-box;
    position:relative;
  }

  .placed {
    position: relative;
  }
  .highlightMode { background: #4b6ef6 !important; color:white; font-size:8px; display:flex;align-items:center;justify-content:center; padding:0; }

  .multiFrostSelect { outline: 2px solid #00e6ff; outline-offset: -2px; }

  .frosted {
    box-shadow: inset 0 0 0 2px rgba(0,180,255,0.35), 0 0 10px rgba(0,180,255,0.08);
  }

  .center-marker {
    position:absolute; width:10px;height:10px;border-radius:50%; background:rgba(255,255,255,0.9); transform: translate(-50%,-50%); pointer-events:none;
  }

  /* Right side (outputs) */
  #rightPanel {
    width:280px;
    display:flex;flex-direction:column;gap:8px;
  }
  .card { background:white;padding:10px;border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.06); }
  h3 { margin:0 0 8px 0; font-size:14px }
  #frostList{margin:0;padding:0;list-style:none; max-height:36vh; overflow:auto}
  #frostList li{padding:6px;border-radius:6px;background:#f6f8fb;margin-bottom:6px;font-size:13px}
  #historyButtons{display:flex;gap:8px}
  .muted{color:#6b7280;font-size:12px}
  .smallInput{width:100%;padding:6px;border-radius:6px;border:1px solid #ddd;margin-top:6px}
  .foot{font-size:12px;color:#667085;margin-top:6px}

/* Mobile-friendly layout */
@media (max-width: 768px) {
  #main {
    flex-direction: column;   /* stack grid and right panel vertically */
    gap: 8px;
  }

  #gridArea {
    width: 100%;              /* full width for the grid */
    overflow-x: auto;         /* allow horizontal scroll if needed */
  }

  #rightPanel {
    width: 100%;              /* full width below the grid */
    order: 2;                 /* appears below the grid */
  }

  #sidebar {
    width: 100%;              /* sidebar full width at top */
  }
}

</style>
</head>
<body>

  <!-- SIDEBAR -->
  <div id="sidebar">
    <h2>Defenses</h2>
    <div id="controls">
      <label class="switch">
        <input type="checkbox" id="modeToggle" checked>
        <span class="slider"></span>
      </label>
      <div id="modeLabel">Image Mode</div>
    </div>

    <button id="exportBtn">Export Grid PNG</button>
    <div id="historyButtons">
      <button id="undoBtn" class="secondary small">Undo</button>
      <button id="redoBtn" class="secondary small">Redo</button>
    </div>
    <div id="editControls" style="display:flex; gap:6px; align-items:center;">
        <label class="switch">
          <input type="checkbox" id="editToggle">
          <span class="slider"></span>
        </label>
        <div id="editLabel">Edit Mode</div>
      </div>
    <div class="hint">Drag a defense onto the grid. Click a placed defense to select for frost. Right-click to remove.</div>

    <div id="defenseScroller" aria-label="defense list"></div>

    <div class="hint muted">Toggle Image vs Highlight mode to see images or just colored names.</div>
  </div>

  <!-- MAIN -->
  <div id="main">
    <div id="gridArea">
        <div id="gridWrapper">
          <div id="grid"></div>
        </div>
    </div>

    <!-- RIGHT PANEL -->
    <div id="rightPanel">
      <div class="card">
        <h3>Frost Spell Deployments</h3>
        <div style="display:flex;gap:8px;margin-bottom:8px">
          <button id="autoPlaceBtn" class="small">Auto-Place Optimal Frosts</button>
          <button id="clearSelectionBtn" class="small secondary">Clear Selection</button>
        </div>
        <ul id="frostList"></ul>
        <div class="foot">Radius: <strong>5 tiles</strong>. Drops are placed so each selected defense's center is covered.</div>
      </div>

      <div class="card">
        <h3>Actions</h3>
        <div style="display:flex;gap:6px;margin-bottom:6px">
          <button id="exportJSON" class="small secondary">Export JSON</button>
          <button id="loadSample" class="small">Load Sample</button>
        </div>
        <div class="muted">You can export layout JSON or the image. Use Load Sample to quickly test.</div>
      </div>

    </div>
  </div>

  <!-- html2canvas for export -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

<script>
/* ========== CONSTANTS ========== */
const DEFENSE_IMAGES = {
  "Cannon": "/defenses/Cannon5C.webp",
  "Spear Thrower": "/defenses/Spear_Thrower5.webp",
  "Multi Cannon": "/defenses/Multi_Cannon5.webp",
  "Bomb Tower": "/defenses/Bomb_Tower5C.webp",
  "Super Giant Post": "/defenses/Super_Giant_Post5.webp",
  "Crusher": "/defenses/Crusher5C.webp",
  "Raid Cart Post": "/defenses/Raid_Cart_Post5.webp",
  "Air Bombs": "/defenses/Air_Bombs5C.webp",
  "Super Wizard Tower": "/defenses/Super_Wizard_Tower5.webp",
  "Air Defense": "/defenses/Air_Defense5C.webp",
  "Multi Mortar": "/defenses/Multi_Mortar5C.webp",
  "Rocket Artillery": "/defenses/Rocket_Artillery5.webp",
  "Mega Hidden Tesla": "/defenses/Hidden_Mega_Tesla5.webp",
  "Super Dragon Post": "/defenses/Super_Dragon_Post5.webp",
  "Goblin Thrower": "/defenses/Goblin_Thrower4.webp",
  "Reflector": "/defenses/Reflector4.webp",
  "Rapid Rockets": "/defenses/Rapid_Rockets5.webp",
  "Inferno Tower": "/defenses/Inferno_Tower5C.webp",
  "Giant Cannon": "/defenses/Giant_Cannon5C.webp",
  "Mini Minion Hive": "/defenses/Mini-Minion_Hive4.webp",
  "Blast Bow": "/defenses/Blast_Bow5.webp",
  "Clan Capital Hall": "/defenses/Capital_Hall10.webp"
};

const DEF_SIZES = {
    "Blast Bow": 4,
    "Clan Capital Hall": 6,
    "Cannon": 2,
    "Spear Thrower": 2,
    "Multi Cannon": 2,
    "Bomb Tower": 2,
    "Super Giant Post": 3,
    "Crusher": 2,
    "Raid Cart Post": 3,
    "Air Bombs": 2,
    "Super Wizard Tower": 2,
    "Air Defense": 2,
    "Multi Mortar": 2,
    "Rocket Artillery": 3,
    "Mega Hidden Tesla": 2,
    "Super Dragon Post": 3,
    "Goblin Thrower": 3,
    "Reflector": 2,
    "Rapid Rockets": 2,
    "Inferno Tower": 3,
    "Giant Cannon": 3,
    "Mini Minion Hive": 3
};

const GRID_SIZE = 30;
const FROST_RADIUS = 5; // tiles

/* ========== DOM ========== */
const gridEl = document.getElementById('grid');
const gridWrapper = document.getElementById('gridWrapper'); // moved up so handlers can use it
const defenseScroller = document.getElementById('defenseScroller');
const modeToggle = document.getElementById('modeToggle');
const modeLabel = document.getElementById('modeLabel');
const frostListEl = document.getElementById('frostList');
const autoPlaceBtn = document.getElementById('autoPlaceBtn');
const clearSelectionBtn = document.getElementById('clearSelectionBtn');
const exportBtn = document.getElementById('exportBtn');
const exportJSON = document.getElementById('exportJSON');
const loadSample = document.getElementById('loadSample');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');

/* ========== STATE ========== */
let placements = [];
let selectedTargets = [];
let computedDrops = [];
let nextPlacementId = 1;

let history = [];
let future = [];

let armedDefense = null;

let posX = 0, posY = 0, scale = 1;
let isPanning = false;
let lastPointer = null;

const IMAGE_CACHE = {};
function preloadDefenseImages(){
  Object.keys(DEFENSE_IMAGES).forEach(name=>{
    const url = DEFENSE_IMAGES[name];
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.src = url;
    IMAGE_CACHE[name] = { img, loaded:false, error:false };
    img.onload = () => IMAGE_CACHE[name].loaded = true;
    img.onerror = () => IMAGE_CACHE[name].error = true;
  });
}
preloadDefenseImages();

/* ========== HELPERS (history, render, utils) ========== */
function cloneState() {
  return {
    placements: JSON.parse(JSON.stringify(placements)),
    selectedTargets: JSON.parse(JSON.stringify(selectedTargets)),
    computedDrops: JSON.parse(JSON.stringify(computedDrops)),
    nextPlacementId
  };
}
function restoreState(snapshot) {
  placements = snapshot.placements;
  selectedTargets = snapshot.selectedTargets;
  computedDrops = snapshot.computedDrops;
  nextPlacementId = snapshot.nextPlacementId;
  renderAll();
}
function saveHistory() {
  history.push(cloneState());
  if (history.length > 100) history.shift();
  future = [];
  updateUndoRedoButtons();
}
function updateUndoRedoButtons() {
  undoBtn.disabled = history.length === 0;
  redoBtn.disabled = future.length === 0;
}

/* Build grid DOM */
function buildGrid() {
  gridEl.innerHTML = '';
  gridEl.style.setProperty('--grid-size', GRID_SIZE);
  for (let r = 0; r < GRID_SIZE; r++) {
    for (let c = 0; c < GRID_SIZE; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.r = r;
      cell.dataset.c = c;
      gridEl.appendChild(cell);
    }
  }
}
buildGrid();

/* Populate sidebar (fixed click-to-arm) */
function populateSidebar() {
  defenseScroller.innerHTML = '';
  Object.keys(DEF_SIZES).forEach(name => {
    const img = document.createElement('img');
    img.draggable = true;
    img.src = DEFENSE_IMAGES[name] || '';
    img.title = name;
    img.alt = name;
    img.dataset.def = name;

    img.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('text/defense', name);
    });

    img.addEventListener('click', () => {
      armedDefense = name;
      [...defenseScroller.children].forEach(i => i.style.outline = '');
      img.style.outline = '2px solid #4b6ef6';
    });

    defenseScroller.appendChild(img);
  });
}
populateSidebar();

/* Utility: transform-aware coordinate conversion */
function getTransformedPoint(clientX, clientY) {
  let el = document.elementFromPoint(clientX, clientY);
  while (el && !el.dataset?.r) el = el.parentElement;
  if (el && el.dataset?.r) {
    return { r: parseInt(el.dataset.r, 10), c: parseInt(el.dataset.c, 10) };
  }

  const rect = gridEl.getBoundingClientRect();
  const x = (clientX - rect.left - posX) / scale;
  const y = (clientY - rect.top - posY) / scale;
  const cellSizeStr = getComputedStyle(document.documentElement).getPropertyValue('--cell-size') || '24';
  const cellSize = parseFloat(cellSizeStr);

  return { r: Math.floor(y / cellSize), c: Math.floor(x / cellSize) };
}

/* Add/remove placements */
function rectsOverlap(r1,c1,s1, r2,c2,s2) {
  return !(r1 + s1 <= r2 || r2 + s2 <= r1 || c1 + s1 <= c2 || c2 + s2 <= c1);
}
function placeDefense(name, r, c) {
  const size = DEF_SIZES[name] || 2;
  if (r < 0 || c < 0 || r + size > GRID_SIZE || c + size > GRID_SIZE) {
    alert('Out of bounds: cannot place there.');
    return;
  }
  for (let p of placements) {
    if (rectsOverlap(r,c,size, p.r, p.c, p.size)) {
      alert('Overlap with existing defense. Place somewhere else.');
      return;
    }
  }
  placements.push({ id: nextPlacementId++, name, r, c, size });
  renderAll();
}
function removePlacementById(id) {
  const idx = placements.findIndex(p => p.id === id);
  if (idx === -1) return;
  placements.splice(idx,1);
  selectedTargets = selectedTargets.filter(x => x !== id);
  computedDrops = [];
  renderAll();
}

/* Render all (considers temporary _tempR/_tempC) */
function renderAll(){
  const cells = gridEl.querySelectorAll('.cell');
  cells.forEach(cell => {
    cell.className = 'cell';
    cell.style.backgroundImage = '';
    cell.textContent = '';
    const img = cell.querySelector('.defense-image');
    if (img) img.remove();
    const cm = cell.querySelector('.center-marker');
    if (cm) cm.remove();
    const fc = cell.querySelector('.frost-center');
    if (fc) fc.remove();
  });

  for (let p of placements) {
    const baseR = (typeof p._tempR === 'number') ? p._tempR : p.r;
    const baseC = (typeof p._tempC === 'number') ? p._tempC : p.c;

    for (let i = 0; i < p.size; i++) {
      for (let j = 0; j < p.size; j++) {
        const rr = baseR + i;
        const cc = baseC + j;
        const cell = gridEl.querySelector(`[data-r="${rr}"][data-c="${cc}"]`);
        if (!cell) continue;
        cell.classList.add('placed');
        if (!modeToggle.checked) {
          cell.classList.add('highlightMode');
          cell.textContent = p.name[0] ?? '';
        }
      }
    }

    if (modeToggle.checked) {
      const tlCell = gridEl.querySelector(`[data-r="${baseR}"][data-c="${baseC}"]`);
      if (tlCell) {
        const img = document.createElement('div');
        img.className = 'defense-image';
        img.style.position = 'absolute';
        img.style.left = '0';
        img.style.top = '0';
        img.style.width = `${p.size * 100}%`;
        img.style.height = `${p.size * 100}%`;
        img.style.backgroundImage = `url(${DEFENSE_IMAGES[p.name] || ''})`;
        img.style.backgroundSize = 'cover';
        img.style.backgroundPosition = 'center';
        img.style.pointerEvents = 'none';
        img.style.zIndex = '2';
        tlCell.appendChild(img);
      }
    }

    const centerR = baseR + Math.floor(p.size / 2);
    const centerC = baseC + Math.floor(p.size / 2);
    const centerCell = gridEl.querySelector(`[data-r="${centerR}"][data-c="${centerC}"]`);
    if (centerCell) {
      let marker = centerCell.querySelector('.center-marker');
      if (!marker) {
        marker = document.createElement('div');
        marker.className = 'center-marker';
        centerCell.appendChild(marker);
      }
    }
  }

  for (let id of selectedTargets) {
    const p = placements.find(x => x.id === id);
    if (!p) continue;
    const baseR = (typeof p._tempR === 'number') ? p._tempR : p.r;
    const baseC = (typeof p._tempC === 'number') ? p._tempC : p.c;
    for (let i = 0; i < p.size; i++) {
      for (let j = 0; j < p.size; j++) {
        const cell = gridEl.querySelector(`[data-r="${baseR + i}"][data-c="${baseC + j}"]`);
        if (cell) cell.classList.add('multiFrostSelect');
      }
    }
  }

  for (let drop of computedDrops) {
    for (let x = -FROST_RADIUS; x <= FROST_RADIUS; x++) {
      for (let y = -FROST_RADIUS; y <= FROST_RADIUS; y++) {
        if (Math.sqrt(x*x + y*y) <= FROST_RADIUS) {
          const cell = gridEl.querySelector(`[data-r="${drop.r + x}"][data-c="${drop.c + y}"]`);
          if (cell) cell.classList.add('frosted');
        }
      }
    }
    const centerCell = gridEl.querySelector(`[data-r="${drop.r}"][data-c="${drop.c}"]`);
    if (centerCell) {
      let red = centerCell.querySelector('.frost-center');
      if (!red) {
        red = document.createElement('div');
        red.className = 'frost-center';
        centerCell.appendChild(red);
      }
    }
  }

  renderFrostList();
}

/* Render frost list */
function renderFrostList() {
  frostListEl.innerHTML = '';
  if (computedDrops.length === 0) {
    frostListEl.innerHTML = '<li class="muted">No frost drops computed. Select defenses and use Auto-Place or click a defense to select center drops.</li>';
    return;
  }
  computedDrops.forEach((drop, idx) => {
    const li = document.createElement('li');
    const coversNames = (drop.covers || []).map(id => (placements.find(p=>p.id===id)||{}).name).filter(Boolean);
    li.textContent = `Drop ${idx+1}: at (${drop.r}, ${drop.c}) — covers: ${coversNames.join(', ') || '—'}`;
    frostListEl.appendChild(li);
  });
}

/* Utility: selected centers */
function euclideanDist(aR,aC,bR,bC) {
  const dx = aR - bR, dy = aC - bC; return Math.sqrt(dx*dx + dy*dy);
}
function getSelectedCenters() {
  return selectedTargets.map(id=>{
    const p = placements.find(x=>x.id===id);
    if (!p) return null;
    return { id: p.id, r: p.r + Math.floor(p.size/2), c: p.c + Math.floor(p.size/2) };
  }).filter(Boolean);
}

/* ========== AUTO OPTIMAL FROST (greedy set cover) ========== */
    function computeOptimalFrostDrops() {
  const centers = getSelectedCenters();
  if (centers.length === 0) {
    alert('No defenses selected. Click defenses to select them for frost first.');
    return;
  }

  // Compute midpoint / centroid of defenses:
  let sumR = 0, sumC = 0;
  for (let pt of centers) {
    sumR += pt.r;
    sumC += pt.c;
  }
  const midR = sumR / centers.length;
  const midC = sumC / centers.length;

  // Single frost drop at midpoint:
  computedDrops = [{
    r: midR,
    c: midC,
    covers: centers.map(pt => pt.id)   // covers all selected defenses
  }];

  saveHistory();
  renderAll();
}
/* Manual center-based compute */
function computeManualFrostsForSelected() {
  computedDrops = selectedTargets.map(id => {
    const p = placements.find(x=>x.id===id);
    const centerR = p.r + Math.floor(p.size/2);
    const centerC = p.c + Math.floor(p.size/2);
    return { r: centerR, c: centerC, covers: [p.id] };
  });
  renderAll();
  saveHistory();
}
window.computeManualFrostsForSelected = computeManualFrostsForSelected;

/* ========== EXPORT PNG (robust) ========== */
exportBtn.addEventListener('click', async () => {
  const cellSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 24;
  const gridPixelsW = GRID_SIZE * cellSize;
  const gridPixelsH = GRID_SIZE * cellSize;
  const exportScale = 2;

  const canvas = document.createElement('canvas');
  canvas.width = Math.round(gridPixelsW * exportScale);
  canvas.height = Math.round(gridPixelsH * exportScale);
  const ctx = canvas.getContext('2d');

  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (let r = 0; r < GRID_SIZE; r++) {
    for (let c = 0; c < GRID_SIZE; c++) {
      const x = Math.round(c * cellSize * exportScale);
      const y = Math.round(r * cellSize * exportScale);
      ctx.fillStyle = '#6b7280';
      ctx.fillRect(x, y, Math.round(cellSize * exportScale), Math.round(cellSize * exportScale));
      ctx.fillStyle = '#222';
      ctx.fillRect(x + Math.round(cellSize * exportScale) - Math.round(1 * exportScale), y, Math.round(1 * exportScale), Math.round(cellSize * exportScale));
      ctx.fillRect(x, y + Math.round(cellSize * exportScale) - Math.round(1 * exportScale), Math.round(cellSize * exportScale), Math.round(1 * exportScale));
    }
  }

  let anyImageError = false;
  for (let p of placements) {
    const px = Math.round(p.c * cellSize * exportScale);
    const py = Math.round(p.r * cellSize * exportScale);
    const pw = Math.round(p.size * cellSize * exportScale);
    const ph = Math.round(p.size * cellSize * exportScale);
    ctx.fillStyle = '#6b7280';
    ctx.fillRect(px, py, pw, ph);
    const cache = IMAGE_CACHE[p.name];
    if (cache && cache.loaded && !cache.error) {
      try { ctx.drawImage(cache.img, px, py, pw, ph); }
      catch (err) { anyImageError = true; console.warn('drawImage failed for', p.name, err); }
    } else {
      anyImageError = anyImageError || (cache && cache.error);
      ctx.fillStyle = '#222';
      ctx.fillRect(px, py, pw, ph);
      ctx.fillStyle = '#fff';
      ctx.font = `${Math.max(10, Math.floor(cellSize * exportScale * 0.35))}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(p.name, px + pw / 2, py + ph / 2, pw - 6);
    }
  }

  for (let drop of computedDrops) {
    for (let dx=-FROST_RADIUS; dx<=FROST_RADIUS; dx++){
      for (let dy=-FROST_RADIUS; dy<=FROST_RADIUS; dy++){
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist <= FROST_RADIUS) {
          const rr = drop.r + dx;
          const cc = drop.c + dy;
          if (rr < 0 || rr >= GRID_SIZE || cc < 0 || cc >= GRID_SIZE) continue;
          const x = Math.round(cc * cellSize * exportScale);
          const y = Math.round(rr * cellSize * exportScale);
          ctx.fillStyle = 'rgba(0,180,255,0.08)';
          ctx.fillRect(x, y, Math.round(cellSize * exportScale), Math.round(cellSize * exportScale));
          ctx.strokeStyle = 'rgba(0,180,255,0.12)';
          ctx.lineWidth = Math.max(1, exportScale);
          ctx.strokeRect(x + 1, y + 1, Math.round(cellSize * exportScale) - 2, Math.round(cellSize * exportScale) - 2);
        }
      }
    }
    const cx = Math.round((drop.c + 0.5) * cellSize * exportScale);
    const cy = Math.round((drop.r + 0.5) * cellSize * exportScale);
    ctx.beginPath();
    ctx.fillStyle = '#ff2b2b';
    ctx.arc(cx, cy, Math.max(3, exportScale * 3), 0, Math.PI*2);
    ctx.fill();
  }

  if (anyImageError) {
    try {
      const fallbackCanvas = await html2canvas(gridEl, {
        backgroundColor: null,
        scale: exportScale,
        useCORS: true,
        allowTaint: true,
        foreignObjectRendering: true
      });
      const link = document.createElement('a');
      link.download = 'frost_planner.png';
      link.href = fallbackCanvas.toDataURL('image/png');
      link.click();
      setTimeout(()=>alert('Note: some external images may be blocked by CORS headers. If defense images are missing, host them on the same origin or allow CORS.'), 20);
      return;
    } catch (err) {
      console.warn('html2canvas fallback failed:', err);
    }
  }

  const link = document.createElement('a');
  link.download = 'frost_planner.png';
  link.href = canvas.toDataURL('image/png');
  link.click();

  if (anyImageError) {
    setTimeout(()=>alert('Some defense images could not be embedded due to cross-origin restrictions. To guarantee images in exports, place the images under your site and update DEFENSE_IMAGES to local paths.'), 50);
  }
});

/* Export JSON */
exportJSON.addEventListener('click', ()=>{
  const exportObj = { placements, selectedTargets, computedDrops, GRID_SIZE, FROST_RADIUS };
  const blob = new Blob([JSON.stringify(exportObj, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'layout.json'; a.click();
  URL.revokeObjectURL(url);
});

/* Load sample */
loadSample.addEventListener('click', ()=>{
  placements = [
    { id: 1, name:'Clan Capital Hall', r:12, c:12, size:6 },
    { id: 2, name:'Cannon', r:8, c:8, size:2 },
    { id: 3, name:'Inferno Tower', r:15, c:6, size:3 },
    { id: 4, name:'Rocket Artillery', r:6, c:18, size:3 },
    { id: 5, name:'Blast Bow', r:18, c:20, size:4 }
  ];
  nextPlacementId = 6;
  selectedTargets = [1,2,4];
  computedDrops = [];
  saveHistory();
  renderAll();
});

/* Undo/Redo */
undoBtn.addEventListener('click', ()=>{
  if (history.length === 0) return;
  future.push(cloneState());
  const snapshot = history.pop();
  restoreState(snapshot);
  updateUndoRedoButtons();
});
redoBtn.addEventListener('click', ()=>{
  if (future.length === 0) return;
  history.push(cloneState());
  const snapshot = future.pop();
  restoreState(snapshot);
  updateUndoRedoButtons();
});

/* Mode toggle */
modeToggle.addEventListener('change', ()=>{
  modeLabel.textContent = modeToggle.checked ? 'Image Mode' : 'Highlight Mode';
  renderAll();
});

/* Clear selection */
clearSelectionBtn.addEventListener('click', ()=>{
  selectedTargets = [];
  computedDrops = [];
  saveHistory();
  renderAll();
});

/* Auto-place */
autoPlaceBtn.addEventListener('click', ()=> computeOptimalFrostDrops());

/* Keyboard shortcuts */
document.addEventListener('keydown', (e)=>{
  if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z') {
    undoBtn.click();
  } else if ((e.ctrlKey||e.metaKey) && (e.shiftKey && e.key.toLowerCase()==='z')) {
    redoBtn.click();
  }
});

/* Render initial state */
saveHistory();
updateUndoRedoButtons();
renderAll();

/* ========== Pointer/Drag events for placing & moving (single system) ========== */
let dragPlacement = null;
let dragOffsetR = 0;
let dragOffsetC = 0;

/* Mousedown for dragging a placed defense (only in edit mode) or start panning */
gridEl.addEventListener('pointerdown', (e) => {
  if (e.isPrimary === false) return;
  const { r, c } = getTransformedPoint(e.clientX, e.clientY);

  if (document.getElementById('editToggle').checked) {
    const placement = placements.find(p => r >= p.r && r < p.r + p.size && c >= p.c && c < p.c + p.size);
    if (placement) {
      dragPlacement = placement;
      dragOffsetR = r - placement.r;
      dragOffsetC = c - placement.c;
      e.preventDefault();
      return;
    }
  }

  isPanning = true;
  lastPointer = { x: e.clientX, y: e.clientY };
  gridEl.setPointerCapture(e.pointerId);
});

/* Pointer move */
gridEl.addEventListener('pointermove', (e) => {
  if (dragPlacement) {
    const { r, c } = getTransformedPoint(e.clientX, e.clientY);
    const newR = r - dragOffsetR;
    const newC = c - dragOffsetC;
    dragPlacement._tempR = newR;
    dragPlacement._tempC = newC;
    renderAll();
    return;
  }
  if (isPanning && lastPointer) {
    const dx = e.clientX - lastPointer.x;
    const dy = e.clientY - lastPointer.y;
    posX += dx;
    posY += dy;
    lastPointer = { x: e.clientX, y: e.clientY };
    applyTransform();
  }
});

/* Pointer up */
gridEl.addEventListener('pointerup', (e) => {
  if (dragPlacement) {
    const { r, c } = getTransformedPoint(e.clientX, e.clientY);
    const newR = r - dragOffsetR;
    const newC = c - dragOffsetC;
    if (newR < 0 || newC < 0 || newR + dragPlacement.size > GRID_SIZE || newC + dragPlacement.size > GRID_SIZE) {
      dragPlacement._tempR = null;
      dragPlacement._tempC = null;
      dragPlacement = null;
      renderAll();
      return;
    }
    const overlap = placements.some(p => p.id !== dragPlacement.id && rectsOverlap(newR, newC, dragPlacement.size, p.r, p.c, p.size));
    if (!overlap) {
      dragPlacement.r = newR;
      dragPlacement.c = newC;
      saveHistory();
    }
    dragPlacement._tempR = null;
    dragPlacement._tempC = null;
    dragPlacement = null;
    renderAll();
    return;
  }

  isPanning = false;
  lastPointer = null;
});

/* --- RIGHT-CLICK DELETE HANDLER (works with zoom/pan/drag) --- */
gridWrapper.addEventListener("contextmenu", (e) => {
    e.preventDefault();

    let target = document.elementFromPoint(e.clientX, e.clientY);

    while (target && !target.dataset?.r) {
        target = target.parentElement;
    }
    if (!target) return;

    const r = parseInt(target.dataset.r, 10);
    const c = parseInt(target.dataset.c, 10);

    const placement = placements.find(
        (p) =>
            r >= p.r &&
            r < p.r + p.size &&
            c >= p.c &&
            c < p.c + p.size
    );
    if (!placement) return;

    if (!confirm(`Remove "${placement.name}"?`)) return;

    removePlacementById(placement.id);
    saveHistory();
});


/* Drag & drop from sidebar to grid (uses elementFromPoint to find cell) */
gridEl.addEventListener('dragover', e => e.preventDefault());

gridEl.addEventListener('drop', (e) => {
  e.preventDefault();

  let target = document.elementFromPoint(e.clientX, e.clientY);
  while (target && !target.dataset?.r) target = target.parentElement;

  let r, c;
  if (target && target.dataset?.r) {
    r = parseInt(target.dataset.r, 10);
    c = parseInt(target.dataset.c, 10);
  } else {
    ({ r, c } = getTransformedPoint(e.clientX, e.clientY));
  }

  const name = e.dataTransfer.getData('text/defense');
  if (!name) return;

  placeDefense(name, r, c);
  saveHistory();
});


/* Click handler (transformed) — handles tap-to-place & selection */
gridEl.addEventListener('click', (e) => {
  // compute cell element first (handles overlays/zoom)
  let cellEl = document.elementFromPoint(e.clientX, e.clientY);
  while (cellEl && !cellEl.dataset?.r) cellEl = cellEl.parentElement;

  let r, c;
  if (cellEl && cellEl.dataset?.r) {
    r = parseInt(cellEl.dataset.r, 10);
    c = parseInt(cellEl.dataset.c, 10);
  } else {
    ({ r, c } = getTransformedPoint(e.clientX, e.clientY));
  }

  // TAP-TO-PLACE
  if (armedDefense) {
    placeDefense(armedDefense, r, c);
    saveHistory();
    armedDefense = null;
    [...defenseScroller.children].forEach(i => i.style.outline = '');
    return;
  }

  const placement = placements.find(p =>
    r >= p.r && r < p.r + p.size &&
    c >= p.c && c < p.c + p.size
  );
  if (!placement) return;
  const idx = selectedTargets.indexOf(placement.id);
  if (idx === -1) selectedTargets.push(placement.id);
  else selectedTargets.splice(idx,1);
  computedDrops = [];
  saveHistory();
  renderAll();
});

/* Touch: pinch to zoom handling on gridWrapper */
let pinchStartDist = 0, pinchStartScale = 1, pinchOrigin = null;

gridWrapper.addEventListener('touchstart', (e) => {
  if (e.touches.length === 2) {
    e.preventDefault();
    pinchStartDist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
    pinchStartScale = scale;
    pinchOrigin = {
      x: (e.touches[0].clientX + e.touches[1].clientX)/2,
      y: (e.touches[0].clientY + e.touches[1].clientY)/2
    };
  }
}, { passive:false });

gridWrapper.addEventListener('touchmove', (e) => {
  if (e.touches.length === 2 && pinchStartDist > 0) {
    e.preventDefault();
    const curDist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
    const newScale = Math.min(Math.max(0.5, pinchStartScale * curDist / pinchStartDist), 3);

    const rect = gridEl.getBoundingClientRect();
    const originX = pinchOrigin.x - rect.left;
    const originY = pinchOrigin.y - rect.top;

    const preZoomX = (originX - posX) / scale;
    const preZoomY = (originY - posY) / scale;

    scale = newScale;

    posX = originX - preZoomX * scale;
    posY = originY - preZoomY * scale;

    applyTransform();
  }
}, { passive:false });

gridWrapper.addEventListener('touchend', (e) => {
  if (e.touches.length < 2) {
    pinchStartDist = 0;
    pinchOrigin = null;
  }
});

/* apply transform to grid */
function applyTransform() {
  gridEl.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
}

/* initialization: ensure transform is applied */
applyTransform();

</script>
</body>
</html>

