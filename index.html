<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Clan Capital Frost Planner â€” Full</title>
<!-- ======= Styles ======= -->
<style>
  :root{
    --sidebar-w: 260px;
    --cell-size: 24px;
    --grid-size: 30;
  }
  #grid {
  touch-action: none;
  transform-origin: 0 0;
}
  body {
    margin: 0;
    height: 100vh;
    display: flex;
    font-family: Inter, system-ui, Arial;
    background: #f0f2f5;
  }

  /* Sidebar */
  #sidebar {
    width: var(--sidebar-w);
    padding: 12px;
    box-sizing: border-box;
    background: #151a22;
    color: #fff;
    display:flex;
    flex-direction: column;
    gap:10px;
  }
  #sidebar h2 { margin:4px 0 8px 0; font-size:18px; }
  #controls { display:flex; gap:8px; align-items:center; }
  .switch{position:relative;width:44px;height:24px}
  .switch input{display:none}
  .slider{position:absolute;inset:0;background:#666;border-radius:24px}
  .slider:before{content:"";position:absolute;left:4px;top:4px;width:16px;height:16px;background:#fff;border-radius:50%;transition:transform .18s}
  .switch input:checked + .slider{background:#2ea44f}
  .switch input:checked + .slider:before{transform:translateX(20px)}
  #modeLabel{font-size:13px;margin-left:6px}
  .frost-center {
  position:absolute;
  width:8px;
  height:8px;
  border-radius:50%;
  background:#ff2b2b;
  transform:translate(-50%,-50%);
  pointer-events:none;
  z-index:5;
}

  #defenseScroller {
    background:#0e1115;
    padding:8px;
    border-radius:8px;
    display:flex;flex-wrap:wrap;gap:8px;max-height:48vh;overflow:auto;
  }
  #defenseScroller img {
    width:46px;height:46px;object-fit:contain;border-radius:6px;background:#222;cursor:grab;
    border:2px solid transparent;
  }
  #defenseScroller img:active{cursor:grabbing}

  button, .small {
    background:#0c7bdc;border:none;color:white;padding:8px;border-radius:6px;cursor:pointer;font-size:13px;
  }
  button.secondary { background:#6c757d;}
  #exportBtn{width:100%}
  .hint{font-size:12px;color:#98a0ab;margin-top:6px}

  /* Main Area */
  #main {
    flex:1;
    display:flex;
    gap:12px;
    padding:12px;
    box-sizing:border-box;
    align-items:flex-start;
  }

  /* Grid container */
  #gridArea{
    background:linear-gradient(#dfe6ee,#e7ecf3);
    padding:10px;border-radius:8px;
  }
  #gridWrapper{
  overflow: hidden;
  touch-action: none;
}

  #grid {
    width: calc(var(--cell-size) * var(--grid-size) + 30px);
    height: calc(var(--cell-size) * var(--grid-size) + 30px);
    display: grid;
    grid-template-columns: repeat(var(--grid-size), var(--cell-size));
    grid-template-rows: repeat(var(--grid-size), var(--cell-size));
    gap:1px;
    background: #222;
    border-radius:6px;
    position: relative;
    user-select: none;
  }

  .cell {
    width: var(--cell-size);
    height: var(--cell-size);
    background: #6b7280;
    display:flex;align-items:center;justify-content:center;
    font-size:9px;color:#fff;
    box-sizing:border-box;
  }

  .placed {
    position: relative;
  }
  .highlightMode { background: #4b6ef6 !important; color:white; font-size:8px; display:flex;align-items:center;justify-content:center; padding:0; }

  .multiFrostSelect { outline: 2px solid #00e6ff; outline-offset: -2px; }

  .frosted {
    box-shadow: inset 0 0 0 2px rgba(0,180,255,0.35), 0 0 10px rgba(0,180,255,0.08);
  }

  .center-marker {
    position:absolute; width:10px;height:10px;border-radius:50%; background:rgba(255,255,255,0.9); transform: translate(-50%,-50%); pointer-events:none;
  }

  /* Right side (outputs) */
  #rightPanel {
    width:280px;
    display:flex;flex-direction:column;gap:8px;
  }
  .card { background:white;padding:10px;border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.06); }
  h3 { margin:0 0 8px 0; font-size:14px }
  #frostList{margin:0;padding:0;list-style:none; max-height:36vh; overflow:auto}
  #frostList li{padding:6px;border-radius:6px;background:#f6f8fb;margin-bottom:6px;font-size:13px}
  #historyButtons{display:flex;gap:8px}
  .muted{color:#6b7280;font-size:12px}
  .smallInput{width:100%;padding:6px;border-radius:6px;border:1px solid #ddd;margin-top:6px}
  .foot{font-size:12px;color:#667085;margin-top:6px}

</style>
</head>
<body>

  <!-- SIDEBAR -->
  <div id="sidebar">
    <h2>Defenses</h2>
    <div id="controls">
      <label class="switch">
        <input type="checkbox" id="modeToggle" checked>
        <span class="slider"></span>
      </label>
      <div id="modeLabel">Image Mode</div>
    </div>

    <button id="exportBtn">Export Grid PNG</button>
    <div id="historyButtons">
      <button id="undoBtn" class="secondary small">Undo</button>
      <button id="redoBtn" class="secondary small">Redo</button>
    </div>

    <div class="hint">Drag a defense onto the grid. Click a placed defense to select for frost. Right-click to remove.</div>

    <div id="defenseScroller" aria-label="defense list"></div>

    <div class="hint muted">Toggle Image vs Highlight mode to see images or just colored names.</div>
  </div>

  <!-- MAIN -->
  <div id="main">
    <div id="gridArea">
        <div id="gridWrapper">
          <div id="grid"></div>
        </div>
      </div>
      
    </div>

    <!-- RIGHT PANEL -->
    <div id="rightPanel">
      <div class="card">
        <h3>Frost Spell Deployments</h3>
        <div style="display:flex;gap:8px;margin-bottom:8px">
          <button id="autoPlaceBtn" class="small">Auto-Place Optimal Frosts</button>
          <button id="clearSelectionBtn" class="small secondary">Clear Selection</button>
        </div>
        <ul id="frostList"></ul>
        <div class="foot">Radius: <strong>5 tiles</strong>. Drops are placed so each selected defense's center is covered.</div>
      </div>

      <div class="card">
        <h3>Actions</h3>
        <div style="display:flex;gap:6px;margin-bottom:6px">
          <button id="exportJSON" class="small secondary">Export JSON</button>
          <button id="loadSample" class="small">Load Sample</button>
        </div>
        <div class="muted">You can export layout JSON or the image. Use Load Sample to quickly test.</div>
      </div>

    </div>
  </div>

  <!-- html2canvas for export -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

<script>
/* ========== CONSTANTS (as provided) ========== */
const DEFENSE_IMAGES = {
  "Cannon": "/defenses/Cannon5C.webp",
  "Spear Thrower": "/defenses/Spear_Thrower5.webp",
  "Multi Cannon": "/defenses/Multi_Cannon5.webp",
  "Bomb Tower": "/defenses/Bomb_Tower5C.webp",
  "Super Giant Post": "/defenses/super_giant_post.webp",
  "Crusher": "/defenses/Crusher5C.webp",
  "Raid Cart Post": "/defenses/Raid_Cart_Post5.webp",
  "Air Bombs": "/defenses/Air_Bombs5C.webp",
  "Super Wizard Tower": "/defenses/super_wizard_tower.webp",
  "Air Defense": "/defenses/Air_Defense5C.webp",
  "Multi Mortar": "/defenses/Multi_Mortar5C.webp",
  "Rocket Artillery": "/defenses/Rocket_Artillery5.webp",
  "Mega Hidden Tesla": "/defenses/Hidden_Mega_Tesla5.webp",
  "Super Dragon Post": "/defenses/Super_Dragon_Post5.webp",
  "Goblin Thrower": "/defenses/Goblin_Thrower4.webp",
  "Reflector": "/defenses/Reflector4.webp",
  "Rapid Rockets": "/defenses/Rapid_Rockets5.webp",
  "Inferno Tower": "/defenses/Inferno_Tower5C.webp",
  "Giant Cannon": "/defenses/Giant_Cannon5C.webp",
  "Mini Minion Hive": "/defenses/Mini-Minion_Hive4.webp",
  "Blast Bow": "/defenses/Blast_Bow5.webp",
  "Clan Capital Hall": "/defenses/Capital_Hall10.webp"
};

const DEF_SIZES = {
    "Blast Bow": 4,
    "Clan Capital Hall": 6,
    "Cannon": 2,
    "Spear Thrower": 2,
    "Multi Cannon": 2,
    "Bomb Tower": 2,
    "Super Giant Post": 3,
    "Crusher": 2,
    "Raid Cart Post": 3,
    "Air Bombs": 2,
    "Super Wizard Tower": 2,
    "Air Defense": 2,
    "Multi Mortar": 2,
    "Rocket Artillery": 3,
    "Mega Hidden Tesla": 2,
    "Super Dragon Post": 3,
    "Goblin Thrower": 3,
    "Reflector": 2,
    "Rapid Rockets": 2,
    "Inferno Tower": 3,
    "Giant Cannon": 3,
    "Mini Minion Hive": 3
};

// ---------- Image preloader ----------
const IMAGE_CACHE = {}; // name -> { img: Image, loaded: boolean, error: boolean }

function preloadDefenseImages() {
  Object.keys(DEFENSE_IMAGES).forEach(name => {
    const url = DEFENSE_IMAGES[name];
    const img = new Image();
    // Try to request anonymous CORS so canvas can read pixels when possible
    img.crossOrigin = 'anonymous';
    img.src = url;

    IMAGE_CACHE[name] = { img, loaded: false, error: false };

    img.onload = () => {
      IMAGE_CACHE[name].loaded = true;
    };
    img.onerror = () => {
      IMAGE_CACHE[name].error = true;
      console.warn(`Failed to load image for ${name} â€” CORS or network may block it:`, url);
    };
  });
}
// call once
preloadDefenseImages();


/* ========== CONFIG ========== */
const GRID_SIZE = 30;
const FROST_RADIUS = 5; // tiles

/* ========== DOM ========== */
const gridEl = document.getElementById('grid');
const defenseScroller = document.getElementById('defenseScroller');
const modeToggle = document.getElementById('modeToggle');
const modeLabel = document.getElementById('modeLabel');
const frostListEl = document.getElementById('frostList');
const autoPlaceBtn = document.getElementById('autoPlaceBtn');
const clearSelectionBtn = document.getElementById('clearSelectionBtn');
const exportBtn = document.getElementById('exportBtn');
const exportJSON = document.getElementById('exportJSON');
const loadSample = document.getElementById('loadSample');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');
let armedDefense = null;      // for mobile tap-to-place
let isDraggingPan = false;
let lastTouch = null;
let scale = 1;
let panX = 0;
let panY = 0;
/* ========== STATE ========== */
// placements: array of { id, name, r, c, size }
// selectedTargets: array of placement ids selected for frost
// computedDrops: array of {r,c, covers: [placementId,...]}
let placements = [];
let selectedTargets = [];
let computedDrops = []; // result of auto or manual compute
let nextPlacementId = 1;

/* History snapshots for undo/redo (simple full-state snapshots) */
let history = [];
let future = [];

/* ========== HELPERS ========== */
function cloneState() {
  return {
    placements: JSON.parse(JSON.stringify(placements)),
    selectedTargets: JSON.parse(JSON.stringify(selectedTargets)),
    computedDrops: JSON.parse(JSON.stringify(computedDrops)),
    nextPlacementId
  };
}
function restoreState(snapshot) {
  placements = snapshot.placements;
  selectedTargets = snapshot.selectedTargets;
  computedDrops = snapshot.computedDrops;
  nextPlacementId = snapshot.nextPlacementId;
  renderAll();
}
function saveHistory() {
  history.push(cloneState());
  // limit history length to avoid memory blow: keep last 100
  if (history.length > 100) history.shift();
  future = [];
  updateUndoRedoButtons();
}
function updateUndoRedoButtons() {
  undoBtn.disabled = history.length === 0;
  redoBtn.disabled = future.length === 0;
}

/* ========== GRID BUILD ========== */
function buildGrid() {
  gridEl.innerHTML = '';
  gridEl.style.setProperty('--grid-size', GRID_SIZE);
  for (let r=0;r<GRID_SIZE;r++){
    for (let c=0;c<GRID_SIZE;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.r = r;
      cell.dataset.c = c;
      gridEl.appendChild(cell);
    }
  }
}
buildGrid();

/* ========== LOAD DEFENSES INTO SIDEBAR ========== */
function populateSidebar() {
  defenseScroller.innerHTML = '';
  Object.keys(DEF_SIZES).forEach(name=>{
    const img = document.createElement('img');
    img.draggable = true;
    img.src = DEFENSE_IMAGES[name] || '';
    img.title = name;
    img.alt = name;
    img.dataset.def = name;
    img.addEventListener('dragstart', (e)=>{
  e.dataTransfer.setData('text/defense', name);
});

/* MOBILE TAP SELECT */
img.addEventListener('click', ()=>{
  armedDefense = name;
  [...defenseScroller.children].forEach(i=>i.style.outline='');
  img.style.outline = '2px solid #4b6ef6';
});

    defenseScroller.appendChild(img);
  });
}
populateSidebar();

/* ========== Drag & Drop onto Grid ========== */
gridEl.addEventListener('dragover', e => e.preventDefault());
gridEl.addEventListener('drop', e => {
  e.preventDefault();
  // compute cell under drop - use elementFromPoint
  let target = document.elementFromPoint(e.clientX, e.clientY);
  // make sure it's a cell (may be child)
  while (target && !target.dataset?.r) target = target.parentElement;
  if (!target) return;
  const r = parseInt(target.dataset.r,10);
  const c = parseInt(target.dataset.c,10);
  const name = e.dataTransfer.getData('text/defense');
  if (!name) return;
  placeDefense(name, r, c);
  saveHistory();
});

/* ========== Place / Remove / Render Placements ========== */
function placeDefense(name, r, c) {
  const size = DEF_SIZES[name] || 2;
  // bounds check
  if (r + size > GRID_SIZE || c + size > GRID_SIZE) {
    alert('Out of bounds: cannot place there.');
    return;
  }
  // check overlap: we disallow overlapping placements
  for (let p of placements){
    if (rectsOverlap(r,c,size, p.r, p.c, p.size)) {
      alert('Overlap with existing defense. Place somewhere else.');
      return;
    }
  }
  const placement = { id: nextPlacementId++, name, r, c, size };
  placements.push(placement);
  renderAll();
}

function rectsOverlap(r1,c1,s1, r2,c2,s2) {
  return !(r1 + s1 <= r2 || r2 + s2 <= r1 || c1 + s1 <= c2 || c2 + s2 <= c1);
}

// Remove a placement by id
function removePlacementById(id) {
  const idx = placements.findIndex(p => p.id === id);
  if (idx === -1) return;
  placements.splice(idx,1);
  // also remove from selectedTargets
  selectedTargets = selectedTargets.filter(x => x !== id);
  computedDrops = [];
  renderAll();
}

/* Render entire grid based on placements, selections and computed drops */
function renderAll(){
  // clear cells
  const cells = gridEl.querySelectorAll('.cell');
  cells.forEach(cell => {
    cell.className = 'cell';
    cell.style.backgroundImage = '';
    cell.textContent = '';
    // remove any stretched images
    const img = cell.querySelector('.defense-image');
    if (img) img.remove();
  });

  // render placements
  for (let p of placements) {

    // mark occupied cells
    for (let i = 0; i < p.size; i++) {
      for (let j = 0; j < p.size; j++) {
        const rr = p.r + i;
        const cc = p.c + j;
        const cell = gridEl.querySelector(`[data-r="${rr}"][data-c="${cc}"]`);
        if (!cell) continue;

        cell.classList.add('placed');

        if (!modeToggle.checked) {
          cell.classList.add('highlightMode');
          cell.textContent = p.name[0] ?? '';
        }
      }
    }

    // stretched image (IMAGE MODE ONLY)
    if (modeToggle.checked) {
      const tlCell = gridEl.querySelector(
        `[data-r="${p.r}"][data-c="${p.c}"]`
      );
      if (tlCell) {
        const img = document.createElement('div');
        img.className = 'defense-image';
        img.style.position = 'absolute';
        img.style.left = '0';
        img.style.top = '0';
        img.style.width = `${p.size * 100}%`;
        img.style.height = `${p.size * 100}%`;
        img.style.backgroundImage = `url(${DEFENSE_IMAGES[p.name] || ''})`;
        img.style.backgroundSize = 'cover';
        img.style.backgroundPosition = 'center';
        img.style.pointerEvents = 'none';
        img.style.zIndex = '2';

        tlCell.appendChild(img);
      }
    }

    // center marker (white dot)
    const centerR = p.r + Math.floor(p.size / 2);
    const centerC = p.c + Math.floor(p.size / 2);
    const centerCell = gridEl.querySelector(
      `[data-r="${centerR}"][data-c="${centerC}"]`
    );
    if (centerCell) {
      let marker = centerCell.querySelector('.center-marker');
      if (!marker) {
        marker = document.createElement('div');
        marker.className = 'center-marker';
        centerCell.appendChild(marker);
      }
    }
  }

  // highlight selected targets
  for (let id of selectedTargets) {
    const p = placements.find(x => x.id === id);
    if (!p) continue;
    for (let i = 0; i < p.size; i++) {
      for (let j = 0; j < p.size; j++) {
        const cell = gridEl.querySelector(
          `[data-r="${p.r + i}"][data-c="${p.c + j}"]`
        );
        if (cell) cell.classList.add('multiFrostSelect');
      }
    }
  }

  // frost area + red center dot
  for (let drop of computedDrops) {

    for (let x = -FROST_RADIUS; x <= FROST_RADIUS; x++) {
      for (let y = -FROST_RADIUS; y <= FROST_RADIUS; y++) {
        if (Math.sqrt(x*x + y*y) <= FROST_RADIUS) {
          const cell = gridEl.querySelector(
            `[data-r="${drop.r + x}"][data-c="${drop.c + y}"]`
          );
          if (cell) cell.classList.add('frosted');
        }
      }
    }

    const centerCell = gridEl.querySelector(
      `[data-r="${drop.r}"][data-c="${drop.c}"]`
    );
    if (centerCell) {
      let red = centerCell.querySelector('.frost-center');
      if (!red) {
        red = document.createElement('div');
        red.className = 'frost-center';
        centerCell.appendChild(red);
      }
    }
  }

  // update frost list
  renderFrostList();
}
/* ========== Click handling: select placement for frost, and right-click delete ========== */
gridEl.addEventListener('click', (e) => {
  let target = e.target;
  while (target && !target.dataset?.r) target = target.parentElement;
  if (!target) return;

  const r = parseInt(target.dataset.r,10);
  const c = parseInt(target.dataset.c,10);

  /* ðŸ‘‰ MOBILE TAP-TO-PLACE */
  if (armedDefense) {
    placeDefense(armedDefense, r, c);
    saveHistory();
    armedDefense = null;
    [...defenseScroller.children].forEach(i=>i.style.outline='');
    return;
  }

  /* ðŸ‘‰ EXISTING FROST SELECTION */
  const placement = placements.find(p =>
    r >= p.r && r < p.r + p.size &&
    c >= p.c && c < p.c + p.size
  );
  if (!placement) return;

  const idx = selectedTargets.indexOf(placement.id);
  if (idx === -1) selectedTargets.push(placement.id);
  else selectedTargets.splice(idx,1);

  computedDrops = [];
  saveHistory();
  renderAll();
});


// right click to remove
gridEl.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  let target = e.target;
  while (target && !target.dataset?.r) target = target.parentElement;
  if (!target) return;
  const r = parseInt(target.dataset.r,10), c = parseInt(target.dataset.c,10);
  const placement = placements.find(p => r >= p.r && r < p.r + p.size && c >= p.c && c < p.c + p.size);
  if (!placement) return;
  if (!confirm('Remove placement "'+placement.name+'"?')) return;
  removePlacementById(placement.id);
  saveHistory();
});

/* ========== Clear Selection ========== */
clearSelectionBtn.addEventListener('click', ()=>{
  selectedTargets = [];
  computedDrops = [];
  saveHistory();
  renderAll();
});

/* ========== Manual frost compute (used when selecting single defense from previous design) ========== */
function computeManualFrostsForSelected() {
  // For each selected defense, frost shall be placed on the center tile of that defense (as defined).
  computedDrops = selectedTargets.map(id => {
    const p = placements.find(x=>x.id===id);
    const centerR = p.r + Math.floor(p.size/2);
    const centerC = p.c + Math.floor(p.size/2);
    return { r: centerR, c: centerC, covers: [p.id] };
  });
  renderAll();
  saveHistory();
}

/* ========== Render frost list ========== */
function renderFrostList() {
  frostListEl.innerHTML = '';
  if (computedDrops.length === 0) {
    frostListEl.innerHTML = '<li class="muted">No frost drops computed. Select defenses and use Auto-Place or click a defense to select center drops.</li>';
    return;
  }
  computedDrops.forEach((drop, idx) => {
    const li = document.createElement('li');
    const coversNames = (drop.covers || []).map(id => (placements.find(p=>p.id===id)||{}).name).filter(Boolean);
    li.textContent = `Drop ${idx+1}: at (${drop.r}, ${drop.c}) â€” covers: ${coversNames.join(', ') || 'â€”'}`;
    frostListEl.appendChild(li);
  });
}

/* ========== Utility: distance, centers list ========== */
function euclideanDist(aR,aC,bR,bC) {
  const dx = aR - bR, dy = aC - bC; return Math.sqrt(dx*dx + dy*dy);
}
function getSelectedCenters() {
  // returns array of {id, r, c}
  return selectedTargets.map(id=>{
    const p = placements.find(x=>x.id===id);
    if (!p) return null;
    return { id: p.id, r: p.r + Math.floor(p.size/2), c: p.c + Math.floor(p.size/2) };
  }).filter(Boolean);
}

/* ========== AUTOMATIC OPTIMAL FROST PLACEMENT (Greedy Set Cover) ========== */
function computeOptimalFrostDrops() {
  const centers = getSelectedCenters();
  if (centers.length === 0) {
    alert('No defenses selected. Click defenses to select them for frost first.');
    return;
  }

  // Candidate drop positions: we can limit to all grid cells (any tile can be a drop center).
  // For speed, we'll use all grid cells, but could also limit to centers of selected defenses and vicinity
  const candidates = [];
  for (let r=0; r<GRID_SIZE; r++){
    for (let c=0; c<GRID_SIZE; c++){
      candidates.push({ r, c, covers: [] });
    }
  }

  // For each candidate compute which centers it covers (distance <= FROST_RADIUS)
  for (let cand of candidates) {
    cand.covers = centers.filter(pt => euclideanDist(cand.r,cand.c,pt.r,pt.c) <= FROST_RADIUS).map(pt=>pt.id);
  }

  // Remove candidates that cover nothing
  const viable = candidates.filter(c => c.covers.length > 0);

  // Greedy set cover:
  const uncovered = new Set(centers.map(pt=>pt.id));
  const drops = [];
  while (uncovered.size > 0) {
    // pick candidate that covers max uncovered
    let best = null; let bestCount = 0;
    for (let cand of viable) {
      // count newly covered
      let cnt = 0;
      for (let id of cand.covers) if (uncovered.has(id)) cnt++;
      if (cnt > bestCount) { best = cand; bestCount = cnt; }
    }
    if (!best) {
      // nothing can cover remaining (shouldn't happen)
      break;
    }
    // add drop at best position
    const coveringIds = best.covers.filter(id => uncovered.has(id));
    drops.push({ r: best.r, c: best.c, covers: coveringIds.slice() });
    // mark uncovered as covered
    coveringIds.forEach(id=>uncovered.delete(id));
    // Optionally remove candidate from viable, but we can leave
  }

  // Save computed drops and render
  computedDrops = drops;
  saveHistory();
  renderAll();
}

/* ========== AUTO BUTTON ========== */
autoPlaceBtn.addEventListener('click', ()=>{
  computeOptimalFrostDrops();
});

/* ========== EXPORT to PNG ========== */
// ---------- Robust export (replaces previous exportBtn handler) ----------
exportBtn.addEventListener('click', async () => {
  // Size calculations: compute pixel size from CSS variables
  const cellSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')) || 24;
  const gridPixelsW = GRID_SIZE * cellSize;
  const gridPixelsH = GRID_SIZE * cellSize;

  // allow the user to choose scale for higher-res exports
  const exportScale = 2;

  // create offscreen canvas
  const canvas = document.createElement('canvas');
  canvas.width = Math.round(gridPixelsW * exportScale);
  canvas.height = Math.round(gridPixelsH * exportScale);
  const ctx = canvas.getContext('2d');

  // optional: white background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // draw grid background similar to your UI (tiles background)
  // You can customize tile color; using same as .cell background
  for (let r = 0; r < GRID_SIZE; r++) {
    for (let c = 0; c < GRID_SIZE; c++) {
      const x = Math.round(c * cellSize * exportScale);
      const y = Math.round(r * cellSize * exportScale);
      ctx.fillStyle = '#6b7280'; // default cell color
      ctx.fillRect(x, y, Math.round(cellSize * exportScale), Math.round(cellSize * exportScale));
      // small gap (grid line) as in your CSS (gap:1px)
      // draw gap as darker line on right and bottom
      ctx.fillStyle = '#222';
      ctx.fillRect(x + Math.round(cellSize * exportScale) - Math.round(1 * exportScale), y, Math.round(1 * exportScale), Math.round(cellSize * exportScale));
      ctx.fillRect(x, y + Math.round(cellSize * exportScale) - Math.round(1 * exportScale), Math.round(cellSize * exportScale), Math.round(1 * exportScale));
    }
  }

  // draw placements: images stretched across their footprint
  // track if any image had a CORS error or didn't load
  let anyImageError = false;

  for (let p of placements) {
    const px = Math.round(p.c * cellSize * exportScale);
    const py = Math.round(p.r * cellSize * exportScale);
    const pw = Math.round(p.size * cellSize * exportScale);
    const ph = Math.round(p.size * cellSize * exportScale);

    // draw a subtle cell background for placed defenses (matches UI)
    ctx.fillStyle = '#6b7280';
    ctx.fillRect(px, py, pw, ph);

    const cache = IMAGE_CACHE[p.name];
    if (cache && cache.loaded && !cache.error) {
      try {
        // draw the cached image stretched
        ctx.drawImage(cache.img, px, py, pw, ph);
      } catch (err) {
        console.warn('drawImage failed for', p.name, err);
        anyImageError = true;
      }
    } else {
      // image not available â€” mark as missing and draw the name as fallback
      anyImageError = anyImageError || (cache && cache.error);
      ctx.fillStyle = '#222';
      ctx.fillRect(px, py, pw, ph);
      ctx.fillStyle = '#fff';
      ctx.font = `${Math.max(10, Math.floor(cellSize * exportScale * 0.35))}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(p.name, px + pw / 2, py + ph / 2, pw - 6);
    }
  }

  // draw frost overlays (use same style as .frosted)
  for (let drop of computedDrops) {
    for (let dx = -FROST_RADIUS; dx <= FROST_RADIUS; dx++) {
      for (let dy = -FROST_RADIUS; dy <= FROST_RADIUS; dy++) {
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist <= FROST_RADIUS) {
          const rr = drop.r + dx;
          const cc = drop.c + dy;
          if (rr < 0 || rr >= GRID_SIZE || cc < 0 || cc >= GRID_SIZE) continue;
          const x = Math.round(cc * cellSize * exportScale);
          const y = Math.round(rr * cellSize * exportScale);
          // draw a translucent blue overlay
          ctx.fillStyle = 'rgba(0,180,255,0.08)';
          ctx.fillRect(x, y, Math.round(cellSize * exportScale), Math.round(cellSize * exportScale));
          // inner highlight
          ctx.strokeStyle = 'rgba(0,180,255,0.12)';
          ctx.lineWidth = Math.max(1, exportScale);
          ctx.strokeRect(x + 1, y + 1, Math.round(cellSize * exportScale) - 2, Math.round(cellSize * exportScale) - 2);
        }
      }
    }
    // red center dot
    const cx = Math.round((drop.c + 0.5) * cellSize * exportScale);
    const cy = Math.round((drop.r + 0.5) * cellSize * exportScale);
    ctx.beginPath();
    ctx.fillStyle = '#ff2b2b';
    ctx.arc(cx, cy, Math.max(3, exportScale * 3), 0, Math.PI*2);
    ctx.fill();
  }

  // if any image had an error (likely due to CORS), fall back to html2canvas with a helpful message
  if (anyImageError) {
    // Attempt a second approach using html2canvas with useCORS; this may still fail but often works for same-origin or permissive CORS
    try {
      const fallbackCanvas = await html2canvas(gridEl, {
        backgroundColor: null,
        scale: exportScale,
        useCORS: true,
        allowTaint: true,
        foreignObjectRendering: true
      });
      const link = document.createElement('a');
      link.download = 'frost_planner.png';
      link.href = fallbackCanvas.toDataURL('image/png');
      link.click();

      // Inform the user why one approach was necessary
      setTimeout(()=>alert('Note: some external images may be blocked by CORS headers. If defense images are missing, host them on the same origin (e.g. /defenses/ on Vercel) or ensure the image server sends Access-Control-Allow-Origin: *'), 10);
      return;
    } catch (err) {
      console.warn('html2canvas fallback failed:', err);
      // continue to save the canvas we created (it will include fallbacks for missing images)
    }
  }

  // Save the generated canvas
  const link = document.createElement('a');
  link.download = 'frost_planner.png';
  link.href = canvas.toDataURL('image/png');
  link.click();

  if (anyImageError) {
    setTimeout(()=>alert('Some defense images could not be embedded due to cross-origin restrictions. To guarantee images in exports, place the images under your site (e.g., /defenses/) and update DEFENSE_IMAGES to local paths.'), 50);
  }
});


/* ========== Export JSON ========== */
exportJSON.addEventListener('click', ()=>{
  const exportObj = { placements, selectedTargets, computedDrops, GRID_SIZE, FROST_RADIUS };
  const blob = new Blob([JSON.stringify(exportObj, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'layout.json'; a.click();
  URL.revokeObjectURL(url);
});

/* ========== Load Sample ========== */
loadSample.addEventListener('click', ()=>{
  // simple sample layout
  placements = [
    { id: 1, name:'Clan Capital Hall', r:12, c:12, size:6 },
    { id: 2, name:'Cannon', r:8, c:8, size:2 },
    { id: 3, name:'Inferno Tower', r:15, c:6, size:3 },
    { id: 4, name:'Rocket Artillery', r:6, c:18, size:3 },
    { id: 5, name:'Blast Bow', r:18, c:20, size:4 }
  ];
  nextPlacementId = 6;
  selectedTargets = [1,2,4];
  computedDrops = [];
  saveHistory();
  renderAll();
});

/* ========== Undo / Redo ========== */
undoBtn.addEventListener('click', ()=>{
  if (history.length === 0) return;
  // current state push to future
  future.push(cloneState());
  const snapshot = history.pop();
  restoreState(snapshot);
  updateUndoRedoButtons();
});

redoBtn.addEventListener('click', ()=>{
  if (future.length === 0) return;
  // push current to history
  history.push(cloneState());
  const snapshot = future.pop();
  restoreState(snapshot);
  updateUndoRedoButtons();
});

/* ========== Mode Toggle ========== */
modeToggle.addEventListener('change', ()=>{
  modeLabel.textContent = modeToggle.checked ? 'Image Mode' : 'Highlight Mode';
  renderAll();
  // we consider mode toggle not to be undoable here (visual only)
});

/* ========== Initialization & helpers ========== */
saveHistory(); // push initial empty state
updateUndoRedoButtons();
renderAll();

/* Expose manual compute in case user wants center-based frost for every selected target: (not required but handy) */
window.computeManualFrostsForSelected = computeManualFrostsForSelected;

/* Nice: if user selects placements, we can compute single-center frost automatically (optional): keep computeManualFrostsForSelected not auto-invoked
   User can choose Auto-Place for optimal or click a placement to select and then call computeManualFrostsForSelected in console if desired.
*/

/* Accessibility: allow keyboard delete of last selected placement */
document.addEventListener('keydown', (e)=>{
  if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z') {
    undoBtn.click();
  } else if ((e.ctrlKey||e.metaKey) && (e.shiftKey && e.key.toLowerCase()==='z')) {
    redoBtn.click();
  }
});
const gridWrapper = document.getElementById('gridWrapper');

gridWrapper.addEventListener('touchstart', e => {
  if (e.touches.length === 1) {
    isDraggingPan = true;
    lastTouch = e.touches[0];
  }
  if (e.touches.length === 2) {
    lastTouch = e.touches;
  }
});

gridWrapper.addEventListener('touchmove', e => {
  e.preventDefault();

  /* PAN */
  if (e.touches.length === 1 && isDraggingPan) {
    const t = e.touches[0];
    panX += t.clientX - lastTouch.clientX;
    panY += t.clientY - lastTouch.clientY;
    lastTouch = t;
    applyTransform();
  }

  /* PINCH ZOOM */
  if (e.touches.length === 2) {
    const [a,b] = e.touches;
    const newDist = Math.hypot(
      a.clientX - b.clientX,
      a.clientY - b.clientY
    );
    if (lastTouch.length === 2) {
      const oldDist = Math.hypot(
        lastTouch[0].clientX - lastTouch[1].clientX,
        lastTouch[0].clientY - lastTouch[1].clientY
      );
      scale *= newDist / oldDist;
      scale = Math.min(Math.max(scale, 0.5), 3);
      applyTransform();
    }
    lastTouch = e.touches;
  }
}, { passive:false });

gridWrapper.addEventListener('touchend', ()=>{
  isDraggingPan = false;
  lastTouch = null;
});

function applyTransform(){
  gridEl.style.transform =
    `translate(${panX}px, ${panY}px) scale(${scale})`;
}
</script>
</body>
</html>